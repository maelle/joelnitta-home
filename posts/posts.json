[
  {
    "path": "posts/2021-11-16_r-bioinfo-flow/",
    "title": "Managing bioinformatics pipelines with R",
    "description": "How to run a complete bioinformatics pipeline from the comfort of R",
    "author": [
      {
        "name": "Joel Nitta",
        "url": "https://joelnitta.com"
      }
    ],
    "date": "2021-11-16",
    "categories": [],
    "contents": "\n\n\n\ntl;dr\ntargets is great for managing bioinformatics workflows\nrenv, Conda, and Docker can be combined so that all steps are modular and reproducible\nDemo available at https://github.com/joelnitta/targets_bioinfo_example\n\n\n\nFigure 1: Image by T K on unsplash.\n\n\n\nBioinformatics projects tend to have a similar pattern: they all start with raw data, then pass the data through various programs until arriving at the final result. These “pipelines” can become very long and complicated, so there are many platforms that automate this process either relying on code (e.g., nextflow, CWL) or graphical interfaces (e.g., galaxy). Python’s snakemake is also commonly used for this purpose. That got me thinking - can we do this in R?\nWhat I’m looking for in a pipeline manager\nThese are some qualities that I want to see in a pipeline manager.\nAutomated: I should be able to run one central script that will orchestrate the whole pipeline, rather than manually keeping track of which step depends on which and when each needs to be run.\nEfficient: The pipeline manager should keep track of what is out of date and only re-run those parts, rather than re-run the whole pipeline each time.\nReproducible: Software packages should be isolated and version controlled so that the same input results in the same output on any machine.\nEnter targets\nThe targets R package pretty much fits the bill perfectly for Points 1 and 2. targets completely automates the workflow, so that the user doesn’t have to manually run steps, and guarantees that the output is up-to-date (if the workflow is designed correctly). Furthermore, it has capabilities for easily looping and running processes in parallel, so it scales quite well to large analyses. I won’t go into too many details of how to use targets here, since it has an excellent user manual.\ntargets meets Docker\nHowever, targets by itself isn’t quite enough to meet all of my bioinformatics needs. What about Point 3–how can we make targets workflows reproducible?\nMost bioinformatics tools are open-source software packages that have a command-line interface (CLI). Furthermore, these days, most well-established bioinformatics tools have Docker images1 available to run them, such as on biocontainers. These free us from manual installations and dependency hell, as well as vastly improving reproducibility, since all the software versions are fixed within the container. So I will run most of the steps of the pipeline in available Docker containers.\nAvoiding Docker-in-Docker\n\n\n\nFigure 2: Image by Giordano Rossoni on unsplash.\n\n\n\nHowever, I then encounter a problem: what about the environment to run R, targets, and launch the Docker containers? That environment should be version-controlled and reproducible too. Normally my solution to create such an environment is Docker, but it’s generally a bad idea to try and run docker from within docker2\nThe solution I reached is to use two more environment managers: Conda3 and renv. I use Conda for running R, and renv for managing R packages.\nRunning R with Conda\nConda environments can be recorded using a yaml file. This is my Conda environment.yaml file:\nname: renv\nchannels:\n  - conda-forge\n  - bioconda\n  - defaults\ndependencies:\n  - r-renv=0.14.*\nIt’s quite short: all it does is install renv and its dependencies (which includes R). Here I’ve specified the most recent major version4 of renv, which will come with R v4.1.1.\nWe can recreate the conda environment from the yaml file (after installing conda) with:\n\n\nconda env create -f environment.yml\n\n\nCollecting package metadata (repodata.json): ...working... done\nSolving environment: ...working... done\nPreparing transaction: ...working... done\nVerifying transaction: ...working... done\nExecuting transaction: ...working... done\n#\n# To activate this environment, use\n#\n#     $ conda activate renv\n#\n# To deactivate an active environment, use\n#\n#     $ conda deactivate\n\nAs the output says near the bottom, run conda activate renv to enter this environment, then from there you can use R as usual. Now we have a fixed version of R, with a fixed version of r-env.\nMaintain R packages with renv\nThe next step is to use renv to install and track R package versions. renv does this with a “lock file”, which is essentially a specification of every package needed to run the code, its version, and where it comes from. This is what a typical lock file looks like (in part):\n{\n  \"R\": {\n    \"Version\": \"4.1.1\",\n    \"Repositories\": [\n      {\n        \"Name\": \"CRAN\",\n        \"URL\": \"https://cloud.r-project.org\"\n      }\n    ]\n  },\n  \"Packages\": {\n    \"Matrix\": {\n      \"Package\": \"Matrix\",\n      \"Version\": \"1.3-4\",\n      \"Source\": \"Repository\",\n      \"Repository\": \"CRAN\",\n      \"Hash\": \"4ed05e9c9726267e4a5872e09c04587c\"\n    },\n...\nI’ve provided an renv.lock file that includes all the packages needed to run the workflow here.\nTo install the R packages, download the renv.lock file and put in the current working directory. Then from R within the conda environment, run renv::restore():\nrenv::restore()\nYou should see something like this5:\n(renv) Joels-iMac:targets_bioinfo_example joelnitta$ Rscript -e 'renv::restore()'\nThe following package(s) will be updated:\n\n# CRAN ===============================\n- Matrix          [* -> 1.3-4]\n- R6              [* -> 2.5.1]\n- Rcpp            [* -> 1.0.7]\n- RcppArmadillo   [* -> 0.10.6.0.0]\n- RcppParallel    [* -> 5.1.4]\n- assertthat      [* -> 0.2.1]\n- babelwhale      [* -> 1.0.3]\n- callr           [* -> 3.7.0]\n\n...\nPutting it all together\nOK, now we have all of the pieces in place, and can run Docker from a reproducible environment. What is the best way to run Docker from R? There are some functions in base R for running external commands (system(), system2()) as well as the excellent processx package. Here, though I will use the babelwhale package, which provides some nice wrappers to run Docker (or Singularity).\nHere is an example _targets.R file using babelwhale to run Docker. This workflow downloads a pair of fasta files, then trims low-quality bases using the fastp program 6.\n\n\nlibrary(targets)\nlibrary(tarchetypes)\nlibrary(babelwhale)\n\n# Set babelwhale backend for running containers\n# (here, we are using Docker, not Singularity)\nset_default_config(create_docker_config())\n\n# Define workflow\nlist(\n  # Download example fastq files\n  tar_file(\n    read_1, { \n      download.file(\n        url = \"https://raw.githubusercontent.com/OpenGene/fastp/master/testdata/R1.fq\",\n        destfile = \"R1.fq\")\n      \"R1.fq\"\n    }\n  ),\n  tar_file(\n    read_2, { \n      download.file(\n        url = \"https://raw.githubusercontent.com/OpenGene/fastp/master/testdata/R2.fq\",\n        destfile = \"R2.fq\")\n      \"R2.fq\"\n    }\n  ),\n  # Clean the fastq file with fastp\n  tar_file(\n    cleaned_fasta_file, {\n      babelwhale::run(\n        # Name of docker image, with tag specifying version\n        \"quay.io/biocontainers/fastp:0.23.1--h79da9fb_0\",\n        # Command to run\n        command = \"fastp\",\n        # Arguments to the command\n        args = c(\n          # fastq input files\n          \"-i\", paste0(\"/wd/\", read_1), \n          \"-I\", paste0(\"/wd/\", read_2), \n          # fastq output files\n          \"-o\", \"/wd/R1_trim.fq\",\n          \"-O\", \"/wd/R2_trim.fq\",\n          # trim report file\n          \"-h\", \"/wd/trim_report.html\"),\n        # Volume mounting specification\n        # this uses getwd(), but here::here() is also a good method\n        volumes = paste0(getwd(), \":/wd/\")\n      )\n      c(\"R1_trim.fq\", \"R2_trim.fq\", \"trim_report.html\")\n    }\n  )\n)\n\n\n\nIn order to run this targets workflow, the above code should be saved as _targets.R in the project root directory. Then, run targets::tar_make(), sit back, and enjoy the show:\n\n\ntargets::tar_make()\n\n\n• start target read_1\ntrying URL 'https://raw.githubusercontent.com/OpenGene/fastp/master/testdata/R1.fq'\nContent type 'text/plain; charset=utf-8' length 3041 bytes\n==================================================\ndownloaded 3041 bytes\n\n• built target read_1\n• start target read_2\ntrying URL 'https://raw.githubusercontent.com/OpenGene/fastp/master/testdata/R2.fq'\nContent type 'text/plain; charset=utf-8' length 3343 bytes\n==================================================\ndownloaded 3343 bytes\n\n• built target read_2\n• start target cleaned_fasta_file\n• built target cleaned_fasta_file\n• end pipeline\n\nYou should be able to confirm that the read files were downloaded, cleaned, and a report generated in your working directory.\nNext steps\n\n\n\nFigure 3: Image by JOHN TOWNER on unsplash.\n\n\n\nThe example workflow just consists of a couple of steps, but I hope you can see how they are chained together: cleaned_fasta_file depends on read_1 and read_2. We could add a third step that uses cleaned_fasta_file for something else, and so forth. targets will keep track of the order that steps need to be run, and only re-run outdated steps if any parts of the workflow change and we run targets::tar_make() again.\nTo keep things simple for this post, I have written the workflow as a single R script, but that’s not really the ideal way to do it. You can see that the syntax is rather verbose, and such a script would rapidly become very long. The best practice for targets workflows is to write the targets plan and the functions that build each target separately, as _targets.R and functions.R, respectively.\nBy splitting the plan from the functions this way, our _targets.R file becomes much shorter and more readable:\n\n\nlibrary(targets)\nlibrary(tarchetypes)\nlibrary(babelwhale)\n\n# Set babelwhale backend for running containers\nset_default_config(create_docker_config())\n\n# Load functions\nsource(\"R/functions.R\")\n\ntar_plan(\n  # Download example fastq files\n  tar_file(read_1, download_read(\"R1.fq\")),\n  tar_file(read_2, download_read(\"R2.fq\")),\n  # Clean the fastq files with fastp\n  tar_file(\n    fastp_out, \n    fastp(read_1, read_2, \"R1_trim.fq\", \"R2_trim.fq\", \"trim_report.html\"\n    )\n  )\n)\n\n\n\nYou can see how it provides a high-level overview of each step in the workflow, without getting bogged down in the details. And the best part is, you don’t have to install fastp (or any other software used for a particular step)! Docker takes care of that for you.\nI have made this plan and the accompanying functions.R file available at this repo: https://github.com/joelnitta/targets_bioinfo_example. Please check it out!\nConclusion\nI am really excited about using targets for reproducibly managing bioinformatics workflows from R. I hope this helps others who may want to do the same!\n\n\nLast updated\n2021-11-19 17:56:02 JST\nDetails\nsource code, R environment\n\n\nDocker images are basically completely self-contained computing environments, such that the software inside the image is exactly the same no matter where it is run. A major benefit of using a docker image is that you don’t have to install all of the various dependencies for a particular package: it all comes bundled in the image. And if the image has been tagged (versioned) correctly, you can specify the exact software version and know that the results won’t change in the future.↩︎\nThink Inception.↩︎\nConda was originally developed for managing python and python packages, but it has expanded greatly and works as a general software package manager.↩︎\nThe asterisk in r-renv=0.14.* indicates to install the most recent version with the 0.14 version number.↩︎\nI’m not actually running this command and showing the output, since this post is already rendered using renv, and running renv within renv is also getting too Inception-y!↩︎\nI won’t go into the details of the targets syntax here, but I highly recommend this chapter in the targets manual for working with external files, which are very common in bioinformatics workflows.↩︎\n",
    "preview": "posts/2021-11-16_r-bioinfo-flow/img/t-k-9AxFJaNySB8-unsplash.jpg",
    "last_modified": "2021-11-22T02:36:49+00:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-06-02_color-scheme-anc-states/",
    "title": "Selecting color schemes for mapping ancestral states",
    "description": "How to change the phytools default color scheme when visualizing the results of ancestral character state estimation",
    "author": [
      {
        "name": "Joel Nitta",
        "url": "https://joelnitta.com"
      }
    ],
    "date": "2021-06-02",
    "categories": [],
    "contents": "\n\n\nThe phytools package provides (among many other things) the contMap() function for estimating ancestral character states and visualizing their changes along the branches of a phylogenetic tree. It can either produce the plot directly (default), or be saved as an object with the plot = FALSE argument, to be further manipulated and plotted later with plot().\nDefault colors\nI have to say I’m not a fan of the default color scheme, which is a rainbow palette going from red through yellow and green to blue.\nFor example, let’s borrow some example code and look at the default plot:\n\n\n# code modified slightly from http://www.phytools.org/eqg2015/asr.html\n\n## Load needed packages for this blogpost\nlibrary(phytools)\nlibrary(ggtree)\nlibrary(tidyverse)\nlibrary(scico)\nlibrary(viridisLite)\n\n## Load anole tree\nanole.tree <- read.tree(\"http://www.phytools.org/eqg2015/data/anole.tre\")\n\n## Load anole trait data, extract snout-vent-length (svl) as named vector\nsvl <- read_csv(\"http://www.phytools.org/eqg2015/data/svl.csv\") %>%\n  mutate(svl = set_names(svl, species)) %>%\n  pull(svl)\n\n# Plot with default color scheme\ncontmap_obj <- contMap(anole.tree, svl, plot = FALSE)\n\nplot(\n  contmap_obj, \n  type=\"fan\", \n  legend = 0.7*max(nodeHeights(anole.tree)),\n  fsize = c(0.5, 0.7))\n\n\n\n\nAlthough this does provide a wide range of colors, it’s not obvious why one color is greater or less than the others. In particular it’s hard to discern the order of intermediate values (yellow, green, light blue). Indeed, there has been much written on why the rainbow palette is generally not a good way to visualize continuous data.\nDefining a new color palette\nphytools::setMap() can be used to specify another color palette. setMap() passes its second argument (a vector of color names or hexadecimals) to colorRampPalette(). colorRampPalette() is a bit unusual in that it’s a function that produces a function, in this case, one that generates a vector of colors interpolating between the original input values:\n\n\n# colorRampPalette() produces a function\nmy_color_func <- colorRampPalette(c(\"red\", \"yellow\"))\nclass(my_color_func)\n\n\n[1] \"function\"\n\n# The function generates n colors interpolating between\n# the colors originally passed to colorRampPalette()\nmy_colors <- my_color_func(n = 6)\nscales::show_col(my_colors)\n\n\n\n\nSo, this works fine for generating custom color gradients. But designing accurate, color-blind friendly color palettes is not a simple task. Fortunately, there are several packages available with such carefully crafted palettes. Two of my favorite are viridis and scico. How can we use these with the plotting function in phytools?\nUsing viridis or scico palettes\nWell, it turns out that as long as we specify the same number of colors, we can replicate the viridis color palette with colorRampPalette(). The only difference is the alpha, or transparency level, indicated at the end of each hexidecimal with two letters (here “FF”). There is no reason to use transparency here anyways, so that doesn’t matter.\n\n\n# viridis color palette with 6 colors\nviridis(6)\n\n\n[1] \"#440154FF\" \"#414487FF\" \"#2A788EFF\" \"#22A884FF\" \"#7AD151FF\"\n[6] \"#FDE725FF\"\n\n# colorRampPalette() replicating viridis color palette\ncolorRampPalette(viridis(6))(6)\n\n\n[1] \"#440154\" \"#414487\" \"#2A788E\" \"#22A884\" \"#7AD151\" \"#FDE725\"\n\nSo here is the viridis version of the phytools plot:\n\n\n# Count the number of unique character states in the observed data:\nn_cols <- n_distinct(svl)\n\n# Change the color palette\ncontmap_obj_viridis <- setMap(contmap_obj, viridis(n_cols))\n\n# Plot the mapped characters with the new colors\nplot(\n  contmap_obj_viridis, \n  type=\"fan\", \n  legend = 0.7*max(nodeHeights(anole.tree)),\n  fsize = c(0.5, 0.7))\n\n\n\n\nAnd here is another one, this time using a palette from scico:\n\n\n# Change the color palette\ncontmap_obj_scico <- setMap(contmap_obj, scico(n_cols, palette = \"bilbao\"))\n\n# Plot the mapped characters with the new colors\nplot(\n  contmap_obj_scico, \n  type=\"fan\", \n  legend = 0.7*max(nodeHeights(anole.tree)),\n  fsize = c(0.5, 0.7))\n\n\n\n\nI personally find this one even easier to interpret than viridis. It’s very clear which values are low and high.\nggtree\nJust for completeness, here is code to replicate the plot in ggtree.\n\n\n# Modified from https://yulab-smu.top/treedata-book/chapter4.html#color-tree\n\n# Fit an ancestral state character reconstruction\nfit <- phytools::fastAnc(anole.tree, svl, vars = TRUE, CI = TRUE)\n\n# Make a dataframe with trait values at the tips\ntd <- data.frame(\n  node = nodeid(anole.tree, names(svl)),\n  trait = svl)\n\n# Make a dataframe with estimated trait values at the nodes\nnd <- data.frame(node = names(fit$ace), trait = fit$ace)\n\n# Combine these with the tree data for plotting with ggtree\nd <- rbind(td, nd)\nd$node <- as.numeric(d$node)\ntree <- full_join(anole.tree, d, by = 'node')\n\nggtree(\n  tree, \n  aes(color = trait), \n  layout = 'circular', \n  ladderize = FALSE, continuous = \"color\", size = 1) +\n  # >>> The important part! <<<\n  # Choose your favorite scale_color_* function here: \n  scale_color_scico(palette = \"bilbao\") + \n  geom_tiplab(hjust = -.1, size = 2, color = \"black\") + \n  xlim(0, 1.2) + \n  theme(\n    legend.position = c(0, .82),\n    legend.text = element_text(size = 8),\n    legend.title = element_text(size = 8)\n  ) \n\n\n\n\nThat’s it!\n\n\nLast updated\n2021-11-18 15:01:50 JST\nDetails\nsource code, R environment\n\n\n\n\n",
    "preview": "posts/2021-06-02_color-scheme-anc-states/featured.png",
    "last_modified": "2021-11-22T02:36:49+00:00",
    "input_file": {}
  },
  {
    "path": "posts/2019-02-16_building-r-docker-images-with-secrets/",
    "title": "Building R docker images with secrets",
    "description": "Keep it secret. Keep it safe.",
    "author": [
      {
        "name": "Joel Nitta",
        "url": "https://joelnitta.com"
      }
    ],
    "date": "2019-02-16",
    "categories": [],
    "contents": "\n\n\n\n\n\n\nFigure 1: Image in the public domain on wikimedia.\n\n\n\nDocker is an incredibly useful tool for running reproducible analysis workflows. For useRs, the rocker collection of images is very convenient for creating version-controlled R environments. This is pretty straightforward if you are using packages on CRAN, or publicly available packages on GitHub. But what if we want to use private packages on GitHub, or need for any other reason to enter authentication credentials during the build?\nThere are various ways to copy data into the image during the build, but when handling secrets that we don’t want hanging around after it’s finished, caution is needed. Approaches such as using COPY or ARGS will leave traces in the build. Staged builds are more secure, but tricky. Fortunately, as of v. 18.09, Docker is now providing official support for handling secrets.\nA simple example\nHere is how to use the new Docker features to securely pass a secret during a build 1.\nThere are few non-default settings that need to be specified for this. First of all, prior to the docker build command, you need to specify that you want to use the new BuildKit backend with DOCKER_BUILDKIT=1. So the command starts DOCKER_BUILDKIT=1 docker build ...\nNext, we must add a syntax directive to the top line of the Dockerfile. For example, for a Dockerfile based on rocker/tidyverse:\n# syntax=docker/dockerfile:1.0.0-experimental\nFROM rocker/tidyverse\nSave your secrets in a text file. Let’s call it my_secret_stash2. If you are using it to store your GitHub PAT, it would just be one line with the PAT. Here, let’s put in some random word:\necho \"FABULOUS\" > my_secret_stash\nThis is all we need to use secrets during the build. Here is an example Dockerfile similar to the one in the Docker documentation.\n# syntax = docker/dockerfile:1.0-experimental\nFROM alpine\n\nRUN --mount=type=secret,id=mysecret cat /run/secrets/mysecret\nTo see how it works, save this as Dockerfile, then from the same directory containing Dockerfile and my_secret_stash, build the image:\nDOCKER_BUILDKIT=1 docker build --progress=plain --no-cache \\\n--secret id=mysecret,src=my_secret_stash .\nI’ve truncated the output, but you should see something like this (the exact build step number may vary).\n\n#7 [2/2] RUN --mount=type=secret,id=mysecret cat /run/secrets/mysecret\n#7       digest: sha256:75601a522ebe80ada66dedd9dd86772ca932d30d7e1b11bba94c04aa55c237de\n#7         name: \"[2/2] RUN --mount=type=secret,id=mysecret cat /run/secrets/mysecret\"\n#7      started: 2019-02-18 20:51:20.1092144 +0000 UTC\n#7 0.668 FABULOUS\n#7    completed: 2019-02-18 20:51:21.0927656 +0000 UTC\n#7     duration: 983.5512ms\n\nCan you spot our secret? It’s showing up from the cat command. However, it will not remain in the image.\nInstalling a private R package\nTo install a package from my private GitHub repo, I created an additional simple R script, called install_git_packages.R:\nsecret <- commandArgs(trailing = TRUE)\ndevtools::install_github(\"joelnitta/my-private-package\", auth_token = secret)\ncommandArgs(trailing = TRUE) will return whatever command line arguments were passed to Rscript after the name of the script, as a character vector.\nWe will call this script from the Dockerfile and pass the secret to it.\nHere is the Dockerfile to do that. (Note that although we copy the install_git_packages.R script into the image, we are passing it the secret variable that is only present during the build, so this should not remain afterwards.)\n# syntax = docker/dockerfile:1.0-experimental\nFROM rocker/tidyverse:3.5.1\n\nENV DEBIAN_FRONTEND noninteractive\n\nCOPY install_git_packages.R .\n\nRUN apt-get update\n\nRUN --mount=type=secret,id=mysecret \\\nRscript install_git_packages.R `cat /run/secrets/mysecret`\nLet’s build the image and tag it:\nDOCKER_BUILDKIT=1 docker build --progress=plain --no-cache \\\n--secret id=mysecret,src=my_secret_stash . -t my_special_image\nThat’s it!\n\n\nLast updated\n2021-11-18 15:06:06 JST\nDetails\nsource code, R environment\n\n\nNo guarantees!! This is just my understanding from reading the docker documentation and other blogs↩︎\nOf course, be sure to add the file containing the secret to .gitignore!↩︎\n",
    "preview": "posts/2019-02-16_building-r-docker-images-with-secrets/featured.png",
    "last_modified": "2021-11-22T02:36:49+00:00",
    "input_file": {}
  }
]
